/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Authors:
 *   Aurelien ROY
 *   Maxime LAFLEUR
 */



#ifndef AICRAFT_PLUGIN_H
#define AICRAFT_PLUGIN_H

#include <stdio.h>
#include <boost/bind.hpp>
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/common/common.hh>
#include <gazebo/common/Plugin.hh>
#include <mav_msgs/CommandMotorSpeed.h>
#include <ros/callback_queue.h>
#include <ros/ros.h>
#include <std_msgs/Float32.h>
#include <array>
#include <mutex>
#include <string>
#include <sdf/sdf.hh>
#include <gazebo/common/PID.hh>
#include <gazebo/common/UpdateInfo.hh>
#include <gazebo/msgs/msgs.hh>
#include <gazebo/physics/PhysicsTypes.hh>
#include <gazebo/transport/TransportTypes.hh>

#define PI      3.1415926536

namespace gazebo {


class AircraftPlugin : public ModelPlugin {
  
  public: AircraftPlugin();

  virtual ~AircraftPlugin();

  virtual void InitializeParams(); 


 protected:
  virtual void UpdateJoints();
  virtual void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf);
  virtual void OnUpdate(const common::UpdateInfo & /*_info*/);
  virtual void OnControl(const mav_msgs::CommandMotorSpeedConstPtr& roll_velocities);

 private:
    private: void UpdatePIDs(double _dt); 

	
    /// \brief Read an SDF parameter with a joint name and initialize a pointer
    /// to this joint.
    /// \param[in] _sdfParam SDF parameter containing a joint name.
    /// \param[in] _sdf Pointer to the SDF element containing the parameters.
    /// \param[out] _joint Pointer to the joint to be initialized.
    /// \return True if the SDF parameter is found and the joint name is found,
    ///         false otherwise.
    bool FindJoint(const std::string &_sdfParam,
        sdf::ElementPtr _sdf, physics::JointPtr &_joint);
/// \brief Joint indexes.
    private: static const unsigned int Aileron  = 0;
    private: static const unsigned int Elevators    = 1;
    private: static const unsigned int Propeller    = 2;
    private: static const unsigned int Rudder       = 3;
    private: static const unsigned int Flap     = 4;

    private: static const unsigned int kLeftAileron  = 0;
    private: static const unsigned int kLeftFlap     = 1;
    private: static const unsigned int kRightAileron = 2;
    private: static const unsigned int kRightFlap    = 3;
    private: static const unsigned int kElevators    = 4;
    private: static const unsigned int kRudder       = 5;
    private: static const unsigned int kPropeller    = 6;

	// \brief Velocity PID for the propeller.
    private: common::PID propellerPID;

std::string command_sub_topic_;
std::string roll_pub_topic_;
std::string namespace_;
	
physics::JointPtr joint_kLeftAileron;
physics::LinkPtr link_kLeftAileron;
std::string joint_kLeftAileron_name_;
std::string link_kLeftAileron_name_;

ros::NodeHandle* node_handle_;
ros::Subscriber command_sub_;

physics::ModelPtr model_;
physics::LinkPtr link_Propeller;
event::ConnectionPtr updateConnection_;

boost::thread callback_queue_thread_;

std_msgs::Float32 turning_angle_kLeftAileron_;
 
    private: std::array<physics::JointPtr, 7> joints;
	private: double sampling_time_ =0;
	private: double prev_sim_time_ = 0;
	private: double rotor_velocity_slowdown_sim_=10;
    /// \brief Max propeller RPM.
    private: int32_t propellerMaxRpm = 2500;
    /// \brief Next command to be applied to the propeller and control surfaces.
    private: std::array<float, 5> cmds;
	/// \brief Position PID for the control surfaces.
    private: std::array<common::PID, 6> controlSurfacesPID;
// \brief keep track of controller update sim-time.
    private: gazebo::common::Time lastControllerUpdateTime;
    /// \brief Controller update mutex.
    private: std::mutex mutex;
	private: double limit_Upper = 0;

	
	

  void QueueThread();
};
}

#endif // ROTORS_GAZEBO_PLUGINS_MOTOR_MODELS_H
